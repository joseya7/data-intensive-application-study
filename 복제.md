## 05. 복제(Replication)

### Introduction
* **복제** : 네트워크로 연결된 여러 장비에 동일한 데이터의 복사본을 유지.
* 왜 **복제**가 필요한 것인가?
    * **지리적**으로 사용자와 가깝게 데이터를 유지해 지연 시간을 줄인다.
    * 시스템의 일부에 장애가 발생해도 지속적으로 동작할 수 있게 해 **가용성**을 높인다.
    * 읽기 질의를 제공하는 장비의 수를 확장해 **읽기 처리량**을 늘린다.
* 복제시 어려운 점
    * 복제된 데이터의 **변경** 처리.
* 노드 간 변경을 복제하기 위한 세 가지 알고리즘
    * 단일 리더(single-leader)
    * 다중 리더(multi-leader)
    * 리더 없는(leaderless)
* Trade-off 
    * 동기 vs 비동기


### 리더와 팔로워 (Leader and Followers)
* 데이터베이스의 복사본을 저장하는 각 노드 -> 복제 서버 (Replica)    
* 모든 복제 서버에 모든 데이터가 있다는 사실을 어떻게 보장할 수 있을까? 
    1. 레플리카 중 하나를 Leader로 지정. (Master or Primary) 
    2. 클라이언트가 데이터베이스에 쓰기를 할 때 클라이언트는 요청을 리더에게 보내야 한다.
    3. 리더는 먼저 로컬 저장소에 새로운 데이터를 기록한다.
    4. 다른 복제 서버 Follower(slave, secondary, read replica)는 리더가 로컬 저장소에 새로운 데이터를 기록할 때마다 데이터 변경을 복제 로그나 변경 스트림의 일부로 팔로워에게 전송한다.
    5. 각 팔로워가 리더로부터 로그를 받으면 리더가 처리한 것과 동일한 순서로 모든 쓰기를 적용해 그에 맞게 데이터 베이스의 로컬 복사본을 갱신.
![image](https://user-images.githubusercontent.com/30207544/168471464-a0555f06-99ed-4745-b9d5-1a1a44b78d42.png)
* 클라이언트가 데이터베이스로부터 읽기를 할 때는 리더 또는 임의 팔로워에게 질의할 수 있다. 하지만 쓰기는 리더에게만 허용된다.

##### 동기식 대 비동기식 복제
* 복제 시스템의 중요한 세부 사항은 복제가 **동기식**, **비동기식**으로 발생하는지 여부
![image](https://user-images.githubusercontent.com/30207544/168471502-bc8bda4d-64ae-4183-ad09-9c2fa77f8e15.png)

* 위 그림을 보면, *Follower 1*의 복제는 동기식이다. 리더는 *Follower 1*이 쓰기를 수신했는지 확인해 줄 때까지 기다린다. 
* *Follower 2*의 복제는 비동기 식이다. *Leader*는 메시지를 전송하짐나 팔로워의 응답을 기다리지 않는다.
* 동기식 복제의 장점은 Follower와 Leader가 일관성 있게 최신 데이터 복사본을 가지는것을 보장한다. 갑자기 리더가 작동하지 않아도 데이터는 팔로워에서 계속 사용할 수 있음을 확신할 수 있다.
* 하지만, 단점도 가지고 있다. 동기 팔로워가 어떤 이유로 응답하지 않는다면 쓰기가 처리될 수가 없다. 리더는 모든 쓰기를 Block하고 동기 복제 서버가 다시 사용할 수 있을때까지 기다려야 한다.
* 이런 이유로 모든 팔로워가 동기식인 상황은 비현실적이다. 한 노드의 장애는 전체 시스템을 멈추게 한다. 현실적으로 데이터베이스에서 동기식 복제를 사용하려면 보통 팔로워 하나는 동기식으로 하고 그 밖에는 비동기식으로 하는 것을 의미한다.
* 보통 리더 기반 복제는 완전히 비동기식으로 구성한다. 이런 경우 리더가 잘못되고 복구할 수 없으면 팔로워에 아직 복제되지 않은 모든 쓰기는 유실된다. 이것은 쓰기가 클라이언트에게 확인된 경우에도 지속성을 보장하지 않는다는 의미다. 하지만 완전 비동기식 설정은 모든 팔로워가 잘못되더라도 쓰기 처리를 계속할 수 있다는 장점이 있다.
* 비동기식 복제는 내구성을 약화시키기 때문에 나쁜 트레이드오프 같지만 그럼에도 특히 많은 팔로워가 있거나 지리적으로 분산됐다면 비동기식 복제를 널리 사용한다.


#### MYSQL 복제 방식
* MYSQL은 기본적으로 **비동기형 복제 방식**을 구현하고 있다.
* MYSQL은 비동기식으로 리더와 팔로워간에 동일한 데이터의 복사본을 유지하기 위해 다음과 같은 구조를 가지고 있다.
![image](https://user-images.githubusercontent.com/30207544/168472295-571b1897-d84e-472f-ac2f-712154d617a6.png)
1. 클라이언트가 실제로 `Commit`을 하게 되면 Master 스토리지 엔진(*InnoDB* 등등)에 실제로 값을 기록하고, 마스터의 변경을 *Binary log*에 기록하게 된다. (*Binary log*는 MySQL서버에서 발생한 모든 변경을 직렬화하여 기록한 파일)
2. **Master thread는** Binary log를 읽어 Slave 서버에 전송한다. 
3. **Slave I/O thread**는 Master로부터 송신받은 데이터를 Relay log라는 로그파일에 보존한다. (Relay log의 포맷은 Binary로그와 완벽하게 같음)
4. **Slave SQL thread**는 Relay log에 갱신된 SQL문을 읽어들여 슬레이브 서버에서 재생하는 역할을 한다. 

#### 새로운 팔로워 설정
* 데이터를 복제할때, 간단히 한 노드에서 다른 노드로 데이터 파일을 복사하는 것만으로는 대개 충분하지 않다.
* 클라이언트는 지속적으로 데이터베이스에 기록하고 데이터는 항상 유동적이기 때문에 표준 파일 복사본은 다른 시점에 데이터베이스의 다른 부분을 보게 된다. 
* 데이터베이스를 잠가서(**Lock**) 디스크의 파일을 일관성 있게 만들 수 있지만 고가용성 목표에 부합하지 않는다. 다행히 팔로워 설정은 대개 중단시간 없이 수행할 수 있다. 그 과정은 개념적으로 다음과 같다.
    1. 가능하다면 전체 데이터베이스를 잠그지 않고 리더의 데이터베이스 Snapshot을 일정 시점에 가져온다. 대부분의 데이터베이스는 백업이 필요하기 때문에 이 기능을 갖췄다. 
        * MYSQL PLUGIN : *innobackupex*, *mysqldump*
        * AWS RDS : *Snapshot* 찍기
    2. 스냅숏을 새로운 팔로워 노드에 복사한다.
        * MYSQL PLUGIN : *mysqldump*
        * AWS RDS : *Snapshot* 복원
    3. 팔로워는 리더에 연결해 Snapshot 이후 발생한 모든 데이터 변경을 요청. 
        * (binlog coordinate: `show master status`, log sequence number)
        * `start slave`
    4. 팔로워가 Snapshot이후 데이터 변경의 미처리분(backlog)을 모두 처리했을 때 따라잡았다고 말한다. 이제부터 리더에 발생하는 데이터 변화를 이어 처리할 수 있다.
        * `show slave status`
        * ![image](https://user-images.githubusercontent.com/30207544/168473513-ba20762a-2c86-4027-aba6-774f065859b7.png)

### 노드 중단 처리
* 시스템의 모든 노드는 장애로 인해 예기지 않게 중단될 수 있음.
* 개별 노드의 장애에도 전체 시스템이 동작하게끔 유지하고 노드 중단의 영향을 최소화하는 것이 목표.
* 리더 기반 복제에서 고가용성은 어떻게 달성할 수 있을지 

#### 팔로워 장애 : 따라잡기 복구
* 각 팔로워는 리더로부터 수신한 데이터 변경 로그를 로컬 디스크에 보관.
* 팔로워가 죽어 재시작 하거나 리더와 팔로워 사이의 네트워크가 일시적으로 중단된다면 팔로워는 매우 쉽게 복구할 수 있음.
* 먼저 보관된 로그에서 결함이 발생하기 전에 처리한 마지막 트랜잭션을 알아낸다.
* 그러면 팔로워는 리더에 연결해 팔로워 연결이 끊어진 동안 발생한 데이터 변경을 모두 요청할 수 있음.

#### 리더 장애 : 장애 복구
* 리더의 장애를 처리하는 일은 까다로움. 팔로워 중 하나를 새로운 리더로 승격해야 하고 클라이언트는 새로운 리더로 쓰기를 전송하기 위해 재설정이 필요.
* 다른 팔로워는 새로운 리더로부터 데이터 변경을 소비하기 시작해야 함.
* 이 과정을 장애 복구 (**Failover**)라 한다.
* 장애 복구는 수동으로 진행하거나 자동으로 진행. 자동 장애 복구는 보통 다음과 같은 단계로 구성.
    1. **리더가 장애인지 판단**. 
    2. **새로운 리더를 선택** 
    3. **새로운 리더 사용을 위해 시스템을 재설정**


### 복제 로그 구현
* 리더 기반 복제는 내부적으로 어떻게 동작하는지에 대해 알아보기
#### 구문 기반 복제 (Statement-based replication)
* 리더는 모든 쓰기 요청(`INSERT`, `DELETE`, `UPDATE`)을 기록하고 쓰기를 실행한 다음 구문 로그를 팔로워에게 전송한다.
* 이 접근법은 합리적인 것 같지만 복제가 깨질 수 있는 다양한 사례가 있다.
    * 현재 날짜와 시간을 얻기 위한 `NOW()` 임의 숫자를 얻기 위한 `RAND()` 같은 비결정적 함수를 호출하는 모든 구문은 각 복제 서버마다 다른 값을 생성할 가능성이 있다.
    * `AUTO-INCREMENTAL`(자동증가 칼럼)을 사용하는 구문이나 데이터베이스에 있는 데이터에 의존한다면 구문은 각 복제 서버에서 정확히 같은 순서로 실행돼야 한다. 
    * 부수효과를 가진 구문은 부수효과가 완벽하게 결정적이지 않으면 각 복제 서버에서 다른 부수 효과가 발생할 수 있다.
* MySQL 5.1이전 버전에서 구문 기반 복제(Statement based replication)이 사용됐다. 하지만 이제 구문에 비결정성이 있다면 기본적으로 로우 기반 복제 (Row-based replication)로 변경한다. 

#### 쓰기 전 로그 배송 (Write-ahead log shipping)
* 3장에서 저장소 엔진이 디스크 상에서 데이터를 표현하는 방법을 살펴봄. 일반적으로 모든 쓰기는 로그에 기록한다는 사실을 확인했다.
    * 로그 구조화 저장소 엔진의 경우 로그 자체가 저장소의 주요 부분. 로그 세그먼트는 작게 유지되고 백그라운드로 가비지 컬렉션 된다.
    * 개별 디스크 블록에 덮어쓰는 B트리의 경우 모든 변경은 쓰기 전 로그(Write-ahead log, WAL)에 쓰기 때문에 고장 이후 일관성 있는 상태로 색인을 복원할 수 있다.
* 두 경우 모두 로그는 데이터베이스의 모든 쓰기를 포함하는 추가 전용(append-only) 바이트 열.
* 완전한 동일 로그를 사용해 다른 노드에서 복제 서버를 구축할 수 있음.
* 리더는 디스크에 로그를 기록하는 일 외에도 팔로워에게 네트워크로 로그를 전송.
* 팔로워가 이 로그를 처리하면 리더에서 있는 것과 정확히 동일한 데이터 구조의 복제본이 만들어짐.
* 이 복제 방식은 PostgreSQL과 Oracle에서 사용됨.
* 가장 큰 단점은, 리더와 팔로워의 데이터베이스 소프트웨어 버전을 다르게 실행할 수 없음.

#### 논리적(로우 기반) 로그 복제 (Row-based replication)
* 복제 로그를 저장소 엔진 내부와 분리하기 위한 대안 하나는 복제와 저장소 엔진을 위해 다른 로그 형식을 사용.
* 관계형 데이터베이스용 논리적 로그는 대개 로우 단위로 데이터베이스 테이블에 쓰기를 기술한 레코드 열이다.
    * 삽입(`INSERT`)된 로우의 로그는 모든 칼럼의 새로운 값을 포함한다.
    * 삭제(`DELETE`)된 로우의 로그는 로우를 고유하게 식별하는데 필요한 정보를 포함한다. (보통 기본키)
    * 갱신(`UPDATE`)된 로우의 로그는 로우를 고유하게 식별하는 데 필요한 정보와 모든 칼럼의 새로운 값을 포함.
* 논리적 로그를 저장소 엔진 내부와 분리했기 때문에 하위 호환성을 더 쉽게 유지할 수 있음.
* 논리적 로그 형식은 외부 애플리케이션이 파싱하기 더 쉬움. 오프라인 분석, 사용자 정의 색인, 캐수 구축을 위해 데이터 웨어 하우스 시스템에 데이터베이스의 내용을 전송하고자 할때 유용. 이 기술을 변경 데이터 캡처(`CDC: Change data capture`)라 부르며 11장에서 설명.
![image](https://user-images.githubusercontent.com/30207544/168580449-efa45142-6caa-4176-9966-972faa2e25a8.png)
![image](https://user-images.githubusercontent.com/30207544/168580581-2c325fd4-a42a-4eb9-a2ee-7adc17c556d0.png)


#### 트리거 기반 복제 (Trigger-based replication)
* 지금까지 설명한 복제 접근 방식은 애플리케이션 코드의 사용 없이 데이터베이스 시스템에 의해 구현
* 데이터베이스의 서브셋만 복제, 데이터베이스를 다른 종류의 데이터베이스로 복제(Mysql -> PostgreSQL)해야 하거나 충돌 해소 로직이 필요하다면 복제를 애플리케이션 층으로 옮겨야 함.
* 오라클의 GoldenGate 같은 도구는 데이터베이스 로그를 읽어 애플리케이션 데이터를 변경할 수 있게함.
* 다른 방법으로는 많은 관계형 데이터베이스에서 사용할 수 있는 기능인 **Trigger**나 **Stored Procedure**를 사용한다.
* 일반적으로 Trigger 기반 복제에는 다른 복제 방식보다 많은 오버헤드가 존재. 이 방식은 데이터베이스에 내장된 복제보다 버그나 제한 사항이 더 많이 발생. 그럼에도 트리거 기반 복제는 유연성 때문에 매우 유용함.

### 복제 지연 문제 (Problems with Replication Lag)
* 리더 기반 복제는 모든 쓰기가 **단일 노드**(Master)를 거쳐야 하지만, 읽기 전용 질의는 어떤 **복제 서버**(Slave, Replica)에서도 가능. 이 방식을 사용하면 리더의 부하를 없애고, 근처 복제 서버에서 읽기 요청을 처리할 수 있게 해준다.
* 이런 *Read-scaling*(읽기 확장) 아키텍처에서는 간단히 팔로워를 추가함으로써 읽기 전용 요청을 처리하기 위한 용량을 늘릴 수 있음. 동기식이라면 단일 노드 장애나 네트워크 중단으로 전체 시스템의 쓰기가 불가능해지기 때문에, 실제로 이 접근방식은 비동기식 복제에서만 동작.
* 애플리케이션이 **비동기 팔로워**에서 데이터를 읽을 때 팔로워가 뒤쳐진다면 지난 정보를 볼 수(Replication Lag)도 있다. 
* 동시에 리더와 팔로워에 동일한 질의를 수행하면, 모든 쓰기가 팔로워에 반여되지 않았기 때문에 서로 다른 결과를 얻을 수도 있다. 
* 이런 불일치는 일시적인 상태에 불과한데, 데이터베이스에 쓰기를 멈추고 잠시동안 기다리면 팔로워는 결국 따라잡게 되고 리더와 일치하게 됨. 이러한 효과를 최종적 일관성(*eventual consistency*)이라 한다.
* 최종적(*eventual*) 이란 용어는 의도적으로 모호한데, 일반적으로 복제 서버가 얼마나 뒤처질 수 있는지에 대한 제한은 없기 때문임.
* 정상적인 경우에는 지연(*Replication lag*)는 아주 짧은 순간임. 하지만 시스템에 네트워크 문제가 생긴다면, 지연은 쉽게 수 초에서 수 분으로 증가할 수 있음.

#### 자신이 쓴 내용 읽기(Reading Your Own Writes)
* 많은 애플리케이션에서 사용자가 데이터를 입력하면, 해당 사용자는 입력한 데이터를 볼 수 있음. (댓글과 같은 경우)
* 비동기식 복제에서는 아래 그림과 같은 문제가 있음.
![image](https://user-images.githubusercontent.com/30207544/168581891-0041afa0-c0b2-44f0-b6b8-17405fca06ee.png)
* 사용자가 쓰기를 수행한 직후 데이터를 본다면, 새로운 데이터는 아직 복제 서버에 반영되지 않았을 수 있음.
* 이런 상황에서는 **쓰기 후 일관성**(*read-after-write consistency*, *read-your-writes*)이 필요. 사용자가 페이지를 재로딩했을 때 항상 자신이 제출한 모든 갱신을 볼 수 있음을 보장. 다른 사용자의 갱신은 일정 시간 이후까지 보이지 않을 수 있지만, 사용자 자신의 입력은 올바르게 저장됄 수 있음을 보장.
* 쓰기 후 읽관성(*read-after-write consistency*)를 구현하기 위한 기법은 다음과 같음.
    * 사용자가 수정한 내용을 읽을 때는 *Leader*에서 읽음. 그 밖에는 *Follower*에서 읽음. SNS에서 사용자 프로필 정보는 보통 다른 사람이 아닌 소유자만 편집 가능. 따라서, 프로필 수정 후 읽기는 항상 Leader에서 읽도록 함.
    * 애플리케이션 내 대부분의 내용을 사용자가 편집할 가능성이 있다면, 위 접근 방식은 대부분 *Leader*에서 읽기 때문에 효율적이지 않음. 읽기 확장 *Read-scaling*의 이점을 무효화함. 이 경우 마지막 갱신 시각을 찾아서, 마지막 갱신 후 1분 동안은 *Leader* 에서 모든 읽기를 수행, *Follower*에서 복제 지연을 모니터링해 리더보다 1분 이상 늦은 모든 *Follower*에 대해 질의를 금지할 수 있음.
    * *Client*는 가장 최근 *쓰기*의 타임스탬프를 기억할 수 있음. 시스템은 사용자 *읽기*를 위한 복제 서버가 최소한 해당 타임스탬프까지 갱신을 반영할 수 있음. 복제 서버가 아직 최신 내용이 아닌 경우에는 다른 복제 서버가 읽기를 처리하도록 함.

* 추가적으로 사용자가 *Desktop*, *Mobile*로 둘다 서비스를 접근할 때 또 다른 문제가 발생. 이 경우는 **디바이스 간**(Cross-Device) 쓰기 후 읽기 일관성이 제공되어야 함. 사용자가 한 Device에서 어떤 정보를 입력하면, 다른 Device에서 볼 때는 방금 입력한 정보가 보여야 함. 이런 경우 몇 가지 문제를 추가적으로 고려해야 함.
    * 이 경우 마지막 갱신 타임스탬프를 기억해야 하는 접근 방식은 더욱 어려움.
    * 복제 서버가 여러 데이터센터간에 분산돼 있다면, 다른 Device의 연결이 동일한 데이터센터로 라우티오딘다는 보장이 없음. 리더에서 읽어야 할 필요가 있는 접근법이라면 먼저 사용자 디바이스의 요청을 동일한 데이터센터로 라우팅 해야함.


#### 단조 읽기(Monotonic Reads)
* 비동기식 팔로워에서 읽을 때 발생할 수 있는 두 번째 이상 현상은 사용자가 시간이 거꾸로 흐르는 현상을 목격할 수 있다는 것.
* 이 사례는 사용자가 각기 다른 복제 서버에서 여러 읽기를 수행할 때 발생
![image](https://user-images.githubusercontent.com/30207544/168585067-2779f1a5-5e69-4f03-a163-2600baf7872b.png)
* 한 사용자(*1234*)가 데이터(댓글)을 입력(*Leader*), 또 다른 사용자(*2345*)가 해당 댓글에 대해 질의(*Follower 1*)를 했을 때 데이터는 존재. 하지만 한번 더 해당 댓글에 질의(이번에는 *Follower 2*)에는 해당 댓글이 존재하지 않음.
* 만약 첫 번째 질의가 아무것도 반환하지 않았다면, 그렇게 나쁜 것은 아님. 사용자 *2345*는 사용자가 *1234*가 최근에 추가한 코멘트를 알지 못하기 때문임. 
* 단조 읽기(*monotonic reads*)는 이런 종류의 이상 현상이 발생하지 않음을 보장. 
* 단조 읽기(*monotonic reads*)를 달성하는 방법은, 각 사용자의 *읽기*가 항상 동일한 복제 서버에서 수행하게끔 하는 것. 

#### 일관된 순서로 읽기(Consistent Prefix Reads)
* 세 번째 복제 지연 이상 현상은 인과성의 위반과 관련되어 있음.
**푼스 씨** : 미래에 대해 얼마나 멀리 볼 수 있나요 케이크 부인?
**케이크 부인**: 보통 10초 정도요. 푼스 씨.
* 위 두 문장 사이에는, 케이크 부인이 푼스씨의 질문을 듣고 답했다는 인과성이 있다.
* 이제 *Follower*를 통해 이 대화를 듣고 있는 제 3관찰자가 있따고 가정해보고, 케이크 부인이 한말은 거의 지연없이 *Follower*에게 전달됐지만, 푼스씨가 한 말은 복제 지연이 있었다.
**케이크 부인**: 보통 10초 정도요. 푼스 씨.
**푼스 씨** : 미래에 대해 얼마나 멀리 볼 수 있나요 케이크 부인?
* 관찰자에게는 케이크 부인이 푼스씨가 물어보기 전에 질문에 대답한 것처럼 보임.
![image](https://user-images.githubusercontent.com/30207544/168586916-2c0dc812-fa44-44d1-af08-5a3b3064a273.png)
* 이러한 종류의 이상 현상을 방지하려면 **일관된 순서로 읽기**(Consistent Prefix Read) 같은 또 다른 유형의 보장이 필요.
* 주로 파티셔닝된 *partitioning*(샤딩*Sahrding*)된 데이터베이스에서 발생하는 특징적인 문제. 
* 데이터베이스가 항상 같은 순서로 쓰기를 적용한다면 읽기는 항상 일관된 순서를 보기 때문에 이런 이상 현상은 일어나지 않음.
* 하지만, 분산 데이터베이스에서 서로 다른 파티션은 독립적으로 동작하므로 쓰기의 전역 순서는 없음. 사용자는 읽을 때 예전 상태의 일부와 새로운 상태의 일부를 함께 볼 수 있음.
* 인과성을 명시적으로 유지하기 위한 알고리즘이 있는데 이 주제는 후에 "이진 발생 관게와 동시성"에서 다시 설명.
