## 다중 리더 복제(Multi Leader Replication)
* 리더 기반 복제 단점 : 리더가 하나만 존재하고 모든 쓰기는 해당 리더를 거쳐야 하므로, 리더에 연결할 수 없다면 데이터베이스에 쓰기를 할 수 없다.
* 다중 리더 복제
    * 다중 리더 복제는 쓰기를 허용하는 노드를 하나 이상 둔다. 
    * 쓰기 처리를 하는 각 노드는 데이터 변경을 다른 모드 노드에 전달한다.
    * 각 리더는 다른 리더의 팔로워 역할도 한다.

### 다중 리더 복제의 사용 사례
#### 다중 데이터센터 운영
![image](https://user-images.githubusercontent.com/30207544/170866399-c70240c4-276e-47d2-8a58-43b9446ff5df.png)
* 다중 리더 설정에서는 각 데이터센터마다 리더가 있을 수 있다. 
* 각 데이터센터 내에는 보통의 **Leader-Follower** 복제를 사용하고 데이터센터 간에는 각 리더가 다른 리더에게 변경사항을 복제한다.
* 아래와 같은 면에서 단일 리더와 다중 리더간에 어떻게 다른지 확인.
    * *성능*
        * 단일 리더 설정에서 모든 쓰기는 인터넷을 통해 리더가 있는 데이터센터로 이동. (쓰기 지연 시간을 늘리는 원인)
        * 다중 리더 설정에서 모든 쓰기는 로컬 데이터센터에서 처리한 다음 비동기 방식으로 다른 데이터센터에 복제
        * 데이터센터 간 네트워크 지연은 사용자에게 숨겨지므로, 사용자가 인지하는 성능은 더 좋아짐.
    * *데이터센터 중단 내성*
        * 단일 리더 설정에서는 리더가 있는 데이터센터가 고장 나면 장애 복구를 위해 다른데이터센터에서 한 팔로워를 리더로 승진.
        * 다중 리더 설정에서는 각 데이터센터는 다른 데이터센터와 독립적으로 동작. 고장 난 데이터센터가 온라인으로 돌아왔을 때 복제를 따라잡음.
    * *네트워크 문제 내성*
        * 데이터센터 간 트래픽은 보통 공개 인터넷을 통해 처리. 그래서 데이터센터 내의 로컬 네트워크보다 안정성이 떨어짐.
        * 단일 리더 설정에서는 데이터센터 내 연결의 쓰기는 동기식이기 때문에 데이터센터 내 연결 문제에 매우 민감.
        * 비동기 복제를 사용하는 다중 리더 설정에서는 네트워크 문제에 보다 잘 견딘다. 일시적인 네트워크 중단에도 쓰기 처리는 진행될 수 있음.

#### 오프라인 작업을 하는 클라이언트
* 다중 리더 복제가 적절한 상황 : 인터넷 연결이 끊어진 동안 애플리케이션이 계속 동작해야하는 경우.
* Calander 앱에서 예를 들자면, 애플리케이션은 인터넷 연결 여부와 관계없이 언제든지 회의를 볼 수 있어야 하고(읽기 요청), 언제라도 새로운 회의에 참가할 수 있어야 한다(쓰기 요청). 오프라인 상태에서 데이터를 변경하면 Device가 다음 온라인 상태가 됐을 때 서버와 다른 다바이스를 동기화.
* 이 경우 모든 Device에는 리더처럼 동작하는 로컬 데이터베이스가 존재 (오프라인 상태에서, 쓰기 요청을 받음.)
* 아키텍처 관점에서, 이 설정은 근본적으로 데이터센터 간 다중 리더 복제와 동일.
    * 각 Device는 "데이터센터"가 되고 Device 간 네트워크 연결은 극히 신뢰할 수 없다. 깨진 캘린더 동기화 구현의 오랜 역사가 보여주는데, 다중 리더 복제는 올바르게 동작하기가 까다로움.
* 카우치 DB는 이런 동작 모드를 위해 설계됨.

#### 협업 편집(Collaborative editing)
*  Etherpad, Google Docs는 동시에 여러 사람이 편집이 가능. (협업 편집)
* 일반적으로 협업 편집을 데이터베이스 복제 문제로 생각하지 않는다. 그러나 협업 편집은 오프라인 편집 사용 사례와 공통점이 많음.
    * 한 사용자가 문서를 편집할 때 변경 내용을 즉시 로컬 복제 서버에 적용.
    * 동일한 문서를 편집하는 다른 사용자와 서버에 비동기 방식으로 복제.
* 편집 충돌이 없음을 보장하려면, 사용자가 편집하기 전에 문서의 잠금(Lock)을 얻어야 한다.
    * 다른 사용자가 같은 문서를 편집하려면 첫 번째 사용자의 변경이 커밋되고, 잠금이 해제될때까지 기다려야 함.
    * 이 협업 모델은 단일 리더 복제와 동일.
* 더 빠른 협업을 위해, 변경 단위를 매우 작게(예를 들어, 단일 키 입력)해서 잠금(Lock)을 피할 수 있다.
    * 이 접근 방식은 여러 사용자가 동시에 편집할 수 있지만, 충돌 해소가 필요한 경우를 포함해 다중 리더 복제에서 발생하는 모든 문제를 야기.

### 쓰기 충돌 다루기(Handling Write Conflicts)
* 다중 리더 복제의 제일 큰 문제 : 쓰기 충돌.
![image](https://user-images.githubusercontent.com/30207544/170868197-da6db05b-b7c7-4c60-8806-a6a9270856e5.png)
* 사용자 1은 페이지 제목을 A에서 B로 변경
* 같은 시각, 사용자 2는 A에서 C로 변경.
* 각 사용자의 변경을 로컬 리더에 성공적으로 적용. 변경을 비동기로 복제할 때 충돌을 감지. 
#### 동기 대 비동기 충돌 감지
* 단일 리더 데이터베이스에서 첫 번째 쓰기가 완료될 때까지, 두 번째 쓰기를 차단해 기다리게 하거나 두 번째 쓰기 트랜잭션을 중단해 사용자가 쓰기를 재도시하게 한다.
    * 반면 다중 리더 설정에서는 두 쓰기는 모두 성공하며 충돌은 이후 특정 시점에서 비동기로만 감지.
    * 이때 사용자에게 충돌을 해소하게끔 요청하면 너무 늦울 수도 있다.
* 이론적으로 충돌 감지는 동기식으로 만들 수 있다.
    * 쓰기가 성공한 사실을 사용자에게 말하기 전에, 모든 복제 서버가 쓰기를 복제하기를 기다린다.
    * 하지만 이렇게 하면 다중 리더 복제 주요 장점을 잃는다.

#### 충돌 회피
* 충돌을 처리하는 제일 간단한 전략은 충돌을 회피.
    * 특정 레코드의 모든 쓰기가 동일한 리더를 거치도록 애플리케이션이 보장한다면 충돌은 발생하지 않음.
    * 많은 다중 리더 복제 구현 사례에서 충돌을 잘 처리하지 못하기 때문에 충돌을 피하는 것을 권장.
* 예를 들어, 사용자가 자신의 데이터를 편집할 수 있는 애플리케이션에서 특정 사용자의 요청을 동일한 데이터센터로 항상 라우팅. 데이터센터 내 리더를 사용해 읽기와 쓰기를 하게끔 보장.
    * 다른 사용자는 서로 다른 "홈"데이터센터를 가질 수 있지만, 한 사용자의 관점에서 보면 구성은 기본적으로 단일 리더.
    * 떄때로 한 데이터 센터가 고장 나서 트래픽을 다른 데이터센터로 다시 라우팅해야 하거나 사용자가 다른 지역으로 이동한다면, 지정된 리더를 변경하고 싶을 수 있다. 
    * 이런 상황에서는 충돌 회피 실패. 다른 리더에서 동시 기록 가능성을 대처해야함.
#### 일관된 상태 수렴
* 단일 리더 데이터베이스는 순차적인 순서로 쓰기를 적용. 동일한 필드를 여러 번 갱신하면, 마지막 쓰기가 필드의 최종값으로 결정.
![image](https://user-images.githubusercontent.com/30207544/170868197-da6db05b-b7c7-4c60-8806-a6a9270856e5.png)
* 다중 리더 설정에서는 쓰기 순서가 정해지지 않아 최종 값이 무엇인지 명확하지 않음.
    * 그림 5-7에서 리더 1의 제목은 B->C, 리더2는 처음에 C로 갱신된 다음 B로 갱신.
    * 이 중에 어떤 순서도 다른 순서보다 "더 정확"하지 않다.
* 단순하게 각 복제 서버가 쓰기를 본 순서대로 적용한다면 데이터베이스는 결국 일관성이 없는 상태가 된다.
    * 리더 1의 최종 값은 C가 되고, 리더2의 최종값은 B가 된다. 이 상황은 용인되지 않는다.
    * 모든 복제 계획은, 모든 복제 서버가 최종적으로 동일하다는 사실을 보장해야함.
    * 따라서 데이터베이스는 **수렴(Convergent)** 방식으로 충돌을 해소해야 한다.
    * 이는 모든 변경이 복제돼 모든 복제 서버에 동일한 최종 값이 전달되게 해야 한다는 의미이다.
* 수렴 충돌 해소를 달성하는 방법은 다양하다.
    * 각 쓰기에 고유 ID를 부여. 가장 높은 ID를 가진 쓰기를 고름. (LWW : Last Write Wins)
    * 각 복제 서버에 고유 ID를 부여하고 높은 숫자의 복제 서버에서 생긴 쓰기가 낮은 숫자의 복제 서버에서 생긴 쓰기보다 항상 우선적으로 적용되게 한다. 값을 병합
    * 명시적 데이터 구조에 충돌을 기록해 모든 정보를 보존. 나중에 충돌을 해소하는 애플리케이션 코드를 작성.
#### 사용자 정의 충돌 해소 로직
* 충돌을 해소하는 가장 적합한 방법은 애플리케이션에 따라 다름. 따라서 대부분의 다중 리더 복제 도구는 애플리케이션 코드를 사용해 충돌 해소 로직을 작성.
* 아래 코드는 쓰기나 읽기 수행 중 실행될 수 있음.
    * 쓰기 수행 중
        * 복제된 변경 사항 로그에서 데이터베이스 시스템이 충돌을 감지하자마자 충돌 핸들러를 호출. (Bucardo)
        * 이 핸들러는 일반적으로 사용자에게 충돌 내용을 표시하지 않음. 백그라운드에서 빠르게 실행
    * 읽기 수행 중
        * 충돌을 감지하면 모든 충돌 쓰기를 저장.
        * 다음 번 데이터를 읽을 때 이런 여런 버전의 데이터가 애플리케이션에 반환.
        * 애플리케이션은 사용자에게 충돌 내용을 보여주거나 자동으로 충돌을 해소할 수 있음. (Couch DB)
* 충돌 해소는 보통 전체 트랜잭션이 아니라 개별 로우나 문서 수준에 적용됨.
    * 따라서, 원자적으로 여러 다른 쓰기를 수행하는 트랜잭션이라면 각 쓰기는 충돌 해소를 위해 여전히 별도로 간주됨.

#### 충돌은 무엇인가?
* 어떤 종류의 충돌은 명백하다.
    * 그림 5-7의 예에서 두 번째 쓰기는 동일한 레코드의 동일한 필드를 동시에 수정해 두 개의 다른 값으로 설정.
* 어떤 종류의 충돌은 감지하기 조금 더 어렵다.
    * 회의실 예약 시스템은 언제, 누가 예약했는지 추적한다.
    * 애플리케이션은 각 회의실이 특정 시간대에 한 사람만 예약하게끔 보장해야 한다. (같은 회의실의 중복 예약은 불가능)
    * 이 때 같은 시간에 같은 회의실을 예약하는 두 개의 다른 예약이 생기면 충돌이 발생.
    * 사용자 예약을 허용하기 전에 애플리케이션이 예약 가능한지 확인하더라도 두 예약이 각기 다른 리더에서 이루지면 충돌이 발생할 수 있다.
* 미리 준비된 답은 없다. 이 문제를 잘 이해하는 방법은 다음 장에서 찾는다. 7장 에서 좀 더 많은 충돌 예제를 살펴본다.
### 다중 리더 복제 토폴로지(Multi-Leader Replication Topologies)
* 복제 토폴로지(Replication Topology)는 쓰기를 한 Node에서 다른 Node로 전달하는 통신 경로를 말함.
![image](https://user-images.githubusercontent.com/30207544/170870004-dcb2db88-7efd-4b17-97ef-5dd4d40d2b94.png)
* 가장 일반적인 Toplogy는 전체 연결(all-to-all)이다. 
    * 이 Toplogy는 모든 Leader가 각자의 쓰기를 다른 모든 Leader에게 전송.
* 원형(Circular) Toplogy는 각 Node가 하나의 Node로부터 쓰기를 받고, 이 쓰기를 한 Node에 전달한다.
    * MYSQL은 기본적으로 Circular Toplogy만 제공. 
* 또 다른 대중적인 Toplogy로 별 모양 (Star) Toplogy가 있다. 
    * Star Toplogy는 지정된 루트 Node 하나가 다른 모든 Node에 쓰기를 전달한다. 
* Circular과 Star Toplogy에서 쓰기는 모든 복제 서버에 도달하기 전에 여러 Node를 거쳐야 한다.
    * Node들은 다른 Node로부터 받은 데이터 변경 사항을 전달해야 한다.
    * 무한 복제 루프를 방지하기 위해 각 Node에는 고유 식별자가 있고 복제 로그에서 각 쓰기는 거치는 모든 Node의 식별자가 Tagging된다.
    * Node가 데이터 변경 사항을 받을 때, 자신의 식별자가 태깅된 경우에는 Node가 이미 처리한 사실을 알기 때문에 데이터 변경 사항을 무시한다.
* Circular과 Star Toplogy의 문제점은 하나의 Node에 장애가 발생하면 장애가 다른 Node 간 복제 메시지 흐름에 방해를 준다는 것.
    * 즉 해당 Node가 복구될 때까지 통신을 할 수 없다.
    * 메시지가 여러 경로를 따라 이동할 수 있으면 단일 장애점을 피할 수 있기 때문에 (all-to-all 처럼) 조금 더 빽빽하게 연결한 Toplogy의 내결함성이 훨씬 더 좋다.
* 반면, 전체 연결 Toplogy도 문제가 있다. 특히 일부 네트워크 연결이 다른 연결보다 빠르다면 아래 그림 처럼 일부 복제 메시지가 다른 메시지를 추월할 수 있다.
    ![image](https://user-images.githubusercontent.com/30207544/170870538-77065474-656e-44e3-a355-3f3798ce554a.png)
* 그림에서 Client A가 Leader 1의 테이블에 Row를 삽입한 뒤 Client B가 Leader 3의 로우를 갱신한다.
    * 하지만 Leader 2는 다른 순서로 쓰기를 받을 수 있다.
    * 먼저 갱신을 받고(Leader 2 관점에서는 데이터베이스에 없는 로우의 갱신임.), 나중에 (갱신 전에 실행됐어야 할) 해당 삽입을 받는다.
* 이는, 지난번에 본 일관된 순서로 읽기에서 본 인과성의 문제다.
    * 갱신은 이전 삽입에 종속적이라 모든 Node에서 먼저 삽입을 처리한 다음 갱신을 처리해야 한다.
    * 모든 쓰기에 간단히 타임스탬프를 추가하는 방식으로 충분하지 않다.
    * Leader 2에서 이런 이벤트를 올바르게 정렬하기에 충분할 정도로 노드들의 시간이 동기화 됐따고 신뢰할 수 없기 때문.

* 이런 이벤트를 올바르게 정렬하기 위해 버전 벡터라고 하는 기법을 사용할 수 있다. 
* 많은 다중 Leader 복제 시스템에서 충돌 감지 기법은 제대로 구현되지 않았다.
    * PostgreSQL에의 BDR은 쓰기의 인과적 순서를 제공하지 않음.
    * MYSQL tungsten replicator는 충돌을 감지하기 위한 시도조차 하지 않는다.
    * 다중 Leader 복제 시스템을 사용하려면 이런 문제를 인지하고 문서를 주의 깊게 읽은 다음 데이터베이스를 철저하게 테스트해 실제로 믿을 만한 보장을 제공하는지 확인하는 편이 좋다.
## 리더 없는 복제 (Leaderless Replication)
* 리더 없는 복제 시스템은 리더의 개념을 버리고 모든 복제 서버가 클라이언트로부터 쓰기를 직접 받을 수 있게 허용한다.
* 리더 없는 복제는 아마존이 내부 다이나모(Dynamo) 시스템에서 사용한 후 다시 데이터베이스용 아키텍처로 유행했다.
* Riak, Cassandra, Voldemort는 다이나모에서 영감을 얻은 리더 없는 복제 모델의 오픈 소스 데이터 스토어이다.
* 이런 종류의 데이터베이스를 다이나모 스타일이라 한다.
### 노드가 다운됐을 때 데이터베이스에 쓰기
![image](https://user-images.githubusercontent.com/30207544/171003833-0ab887e0-07be-4c51-b372-b7b3612e720f.png)
* 세 개의 복제 서버를 가진 데이터베이스가 있고, 복제 서버중 하나를 사용할 수 없다고 가정했을 때, 리더 기반 설정에서 쓰기 처리를 계속 하려면 장애 복구를 실행해야 한다.
* 반면 리더 없는 설정에서는 장애 복구가 필요하지 않다.
    * 클라이언트가 쓰기를 세 개의 모든 복제 서버에 병렬로 전송한다.
    * 사용 가능한 두 개의 복제 서버는 쓰기를 받았짐나, 사용 불가능한 복제 서버는 쓰기를 놓쳤다.
    * 사용자 1234가 두 개의 `ok` 응답을 받은 후에는 쓰기가 성공한 것으로 간주한다.
    * 클라이언트는 복제 서버 중 하나가 쓰기를 놓친 사실을 단순히 무시한다.
    * 이제 사용할 수 없었던 노드가 다시 온라인 상태가 되고, 클라이언트가 이 노드에서 읽기를 시작하면, 노드가 다운된 동안 발생한 모든 쓰기는 해당 노드에서 누락됐다.
    * 따라서 클라이언트가 해당 노드에서 데이터를 읽는다면 응답으로 **오래된(outdated)** 값을 얻을 수 있다.
* 이 문제를 해결하기 위해서는 클라이언트가 데이터 베이스를 읽을 때 하나의 복제 서버로 요청을 보내지 않고, 읽기 요청을 병렬로 여러 노드에 전송한다.
    * 그러면 클라이언트는 여러 노드에서 다른 응답을 받을 수 있다.
    * 즉 한 노드에서는 최신 값을 받고, 다른 노드에서는 오래된 값을 받는다.
    * 이때는 버전 숫자를 사용해 어떤 값이 최신 내용인지 결정한다.
#### 읽기 복구와 안티 엔트로피(Read repair and anti-entropy)
* 사용 불가능한 노드가 온라인 상태가 된 후 누락된 쓰기를 어떻게 따라잡아야 할까?
    * 다이나모 스타일 데이터 스토어는 두 가지 메커니즘을 주로 사용한다.
        *  읽기 복구
            * 클라이언트가 여러 노드에서 병렬로 읽기를 수행하면 오래된 응답을 감지 할 수 있다.
            * 예를 들어, 위 그림에서 `user 2345` 는 *복제 서버3*에서 *버전 6*의 값을 얻고 *복제 서버 1과 2*에서 *버전7*의 값을 얻는다.
            * *복제 서버3* 값이 오래된 값이라는 사실을 알고 해당 복제 서버에 새로운 값을 다시 기록.
        * 안티 엔트로피 처리
            * 추가적으로 일부 데이터스토어는 백그라운드 프로세스를 두고 복제 서버 간 데이터 차이를 지속적으로 찾아 누락된 데이터를 하나의 복제 서버에서 다른 서버로 복사한다.
    * 모든 시스템이 이 두가지 메커니즘을 모두 구현하는 건 아니다.
        * Voldemort는 현재 안티 엔트로피를 처리하지 않는다.
        * 안티 엔트로피 처리가 없으면 읽기 복구는 애플리케이션이 값을 읽는 경우에만 수행되기 때문에 거의 읽지 않는 값은 일부 복제본에서 누락돼 내구성이 떨어진다.                        
#### 읽기와 쓰기를 위한 정족수(Quorums for reading and writing)
* 모든 성공한 쓰기가 세 개의 복제 서버 중 적어도 두 개의 복제 서버에 존재한다는 것을 보장한다면, 하나의 복제 서버가 오래된 데이터임을 의미한다.
    * 따라서 적어도 두 개의 복제 서버에서 읽으면 두 개중 적어도 하나는 최신 값인지 확인할 수 있다.
    * 세 번째 복제 서버가 다운되거나 응답이 느린 경우에도 읽기는 최신 값을 계속 반환할 수 있다.
* `n`개의 복제 서버가 있을 때, 모든 쓰기는 `w`개의 노드에서 성공해야 쓰기가 확정되고, 모든 읽기는 최소한 `r`개의 노드에 질의해야 한다.
    * `w + r > n`이면 읽을 때 최신 값을 얻을 것으로 기대한다. (위 예에서, n=3, w=2, r=2)
    * 최소한 `r`개의 노드 중 하나에서 최신 값을 읽을 수 있기 때문이다.
    * 이런 `r`과 `w`를 따르는 읽기와 쓰기를 정족수 읽기와 쓰기라고 부른다.
    * 유효한 읽기와 쓰기를 필요한 최소 투표수를 `r`과 `w`로 생각할 수 있다.
* 다이나모 스타일 데이터베이스에서 `n`, `w`, `r` 파라미터는 대개 설정 가능하다.
    * 일반적인 선택은 n을 홀수 (보통 3이나 5)로 하고 `w = r = (n+1) / 2` (반올림)로 설정한다.
* 정족수 조건이 `w + r > n`이면 다음과 같이 사용 불가능한 노드를 용인한다.
    * `w < n`이면 노드 하나를 사용할 수 없어도 여전히 쓰기를 처리할 수 있다.
    * `r < n`이면 노드 하나를 사용할 수 없어도 여전히 읽기를 처리할 수 있다.
    * n = 3, w = 2, r = 2 이면 사용 불가능한 노드 하나를 용인한다.
    * n = 5, w = 3, r = 3 이면 사용 불가능한 노드 둘을 용인한다. 
    * 일반적으로 읽기와 쓰기는 항상 모든 n개의 서버에 병렬로 전송한다. 파라미터 `w`와 `r`은 얼마나 많은 노드를 기다릴지 결정한다. 즉 읽기나 쓰기가 성공했다고 간주하려면 n개의 노드 중 몇 개의 노드에서 성공을 확인해야 하는지를 나타난다.
    ![image](https://user-images.githubusercontent.com/30207544/171008306-d5b55c54-7e43-461d-a77a-f39bf6763c3e.png)
* 필요한 w나 r개 노드보다 사용 가능한 노드가 적다면 쓰기나 읽기는 에러를 반환한다.    
### 정족수 일관성의 한계
* `n`개의 복제 서버가 있고 `w + r > n`이 되게끔 `w`와 `r`을 선택한다면 일반적으로 모든 읽기는 키의 최신 값을 반환할 것을 기대한다.
    * 이는 쓰기를 하는 노드 셋과 읽기를 하는 노드 셋이 겹치기 때문이다. 
    * 즉 읽은 노드 중에는 최신 값을 가진 노드가 하나 이상 있어야 한다.
* 보통 `r`과 `w`의 값으로 노드의 과반수를 선택한다.
    * 이유는 `n/2` 노드 장애까지 허용해도 w + r > n 이 보장되기 때문이다.
    * 하지만 정족수가 다수일 필요는 없다.
    * 읽기와 쓰기 동작에서 사용하는 노드 셋 중 적어도 하나의 겹치면 된다.
* 또한 `w`와 `r`을 더 작은 수로 설정해 `w + r <= n`이 되게끔 설정할 수도 있다.
    * 이 경우에는 읽기와 쓰기를 계쏙 n개의 노드로 전송하지만 성공에 필요한 성공 응답의 수는 더 적다.
* `w`와 `r`이 작을수록 오래된 값을 읽을 확률이 높다.
    * 최신 값을 가진 노드가 읽을 노드에 포함되지 않을 가능성이 높기 때문이다.
* 하지만 `w + r > n` 인 경우에도 오래된 값을 반환하는 Edge case가 있다. 구현에 따라 다르지만 다음 시나리오가 가능하다.
    * 느슨한 정족수를 사용한다면, `w`개의 쓰기는 `r`개의 읽기와 다른 노드에서 수행될 수 있으므로 `r`의 노드와 `w`개의 노드가 겹치는 것을 보장하지 않는다.
    * 두 개의 쓰기가 동시에 발생하면, 어떤 쓰기가 먼저 일어났는지 분명하지 않다. 
        * 이 경우 동시 쓰기를 합치는 방법밖에 없다. 승자가 타임스탬프를 기반으로 결정되면(최종 쓰기 승리), Clock skew로 인해 쓰기가 유실될 수 있다.
    * 쓰기가 일부 복제 서버에서는 성공했지만 다른 복제 서버에서 실패해, 전체에서 성공한 서버가 w 복제 서버보다 적다면 성공한 복제 서버에서는 롤백하지 않는다. 이는 쓰기가 실패한 것으로 보고되면 이어지는 읽기에 해당 쓰기 값이 반환될 수도 있고 아닐 수도 있다는 의미다.
* 정족수 읽기 시 최근에 쓴 값을 반환하게 끔 보장하지만 실제로는 그렇게 간단하지 않다.
    * 매개변수 w와 r로 오래된 값을 읽는 확률을 조정할 수 있지만, 이를 절대적으로 보장할 수 는 없다.
    * 특히, 전에 설명한 "복제 지연 문제"와 관련된 보장을 대개 받을 수 없기 때문에, 관련된 이상 현상이 애플리케이션에 발생할 수 있다.
    * 견고한 보장은 일반적으로 트랜잭션이나 합의가 필요한데, 이 주제는 7장과 9장에서 다시 설명한다.
#### 최신성 모니터링
* 운영 관점에서 볼 때 데이터베이스가 최신 결과를 반환하는지 여부를 모니터링하는 일은 중요하다.
    * 애플리케이션이 오래된 값 읽기를 허용하더라도 복제 상태에 대해 알아야 한다.
    * 복제가 명확히 뒤쳐진다면 원인을 조사할 수 있게 알려줘야 한다.
* 리더 없는 복제에서 쓰기가 적용된 순서를 고정할 수 없어 모니터링이 어렵다
    * 데이터베이스가 읽기 복구만 사용(Anti-Entropy는 사용하지 않음)한다면 자주 읽지 않는 값이 얼마나 오래된 것인지에 대한 제한이 없어 오래된 복제 서버에서 반환된 값은 아주 오래된 값일 수 있다.
* 데이터베이스를 위한 표준 지표 셋에 오래됨을 측정하게끔 추가하는 작업은 좋은 일이다. 
    * 최종적 일관성은 의도적으로 모호한 보장이지만 운용성을 위해서는 "최종적"을 정량화할 수 있어야 한다.
### 느슨한 정족수와 암시된 핸드오프
* 적절히 설정된 정족수가 있는 데이터베이스는 장애 복구 없이 개별 노드 장애를 용인한다.
    * 또한 요청은 `w`나 `r`개 노드가 응답할 때 반환할 수 있어 모든 n개 노드가 응답할 때까지 기다릴 필요가 없기 때문에 개별 노드의 응답이 느려지는 것도 허용 가능하다.
    * 가끔 오래된 값 읽기를 허용하는 사용 사례에는 리더 없는 복제 기능을 가진 데이터베이스가 매력적이다.
* 하지만, 정족수는 내결함 성이 없다.
    * 네트워크 중단으로 다수의 데이터베이스 노드와 클라이언트는 쉽게 연결이 끊어질 수 있다.
    * 비록 데이터베이스 노드가 살아 있고, 다른 클라이언트가 데이터베이스 노드 및 데이터베이스 노드와 연결이 끊긴 클라이언트에 연결할 수 있을지라도 데이터베이스 노드는 죽은 것과 같다.
    * 이 상황에서 응답 가능한 노드가 `w`나 `r`보다 적을 가능성이 있으므로 클라이언트는 더 이상 정족수를 충족할 수 없다.
* 노드가 `n`개 이상인 대규모 클러스터에서 클라이언트는 네트워크 장애 상황에서 일부 데이터베이스 노드(특정 값을 위한 정족수 구성에 들어가지 않는 노드)에 연결될 가능성이 있다.
    * 이 경우 두가지를 선택해야 한다.
        * `w`나 `r`노드 정족수를 만족하지 않는 모든 요청에 오류를 반환하는 편이 더 좋을까?
        * 아니면 일단 쓰기를 받아들이고, 값이 보통 저장되는 `n`개 노드에 속하지는 않지만 연결할 수 있는 노드에 기록할까?
* 후자를 느슨한 정족수라 부른다.
    * 쓰기와 읽기는 여전히 `w`와 `r`의 성공 응답이 필요하지만, 값을 위해 지정된 `n`개의 "홈"노드에 없는 노드가 포함될 수 있다.
    * 비유하자면, 내 집 문이 잠겨 들어갈 수 없다면 이웃집 문을 두드려 소파에 잠시 머물 수 있는지 묻는 상황과 같다.
* 네트워크 장애 상황이 해재되면, 한 노드가 다른 노드를 위해 일시적으로 수용한 모든 쓰기를 해당 "홈" 노드로 전송한다.
    * 이 방식을 암시된 핸드오프(**Hinted Handoff**)라 부른다. (내 집 열쇠를 다시 찾으면 이웃이 정중하게 소파에서 일어나 집으로 돌아가라고 요청한다.)
* 느슨한 정족수는 쓰기 가용성을 높이는데 특히 유용하다.
    * 모든 `w`개의 노드를 사용할 수 있는 동안은 데이터베이스 쓰기를 받아들일 수 있다.
    * 하지만 이것은 w + r > n인 경우에도 키의 최신값을 읽는다고 보장하지 않는다.
    * 최신 값이 일시적으로 n 이외의 일부 노드에 기록될 수 있기 때문이다.
* 따라서 느슨한 정족수는 실제로 전통적인 의미의 정족수가 아니다.
    * 단지 지속성에 대한 보장으로 데이터가 w 노드 어딘가에는 저장된다는 뜻이다.
    * 암시된 핸드오프가 완료될 때까지는 `r` 노드의 읽기가 저장된 데이터를 본다는 보장은 없다.
* 느슨한 정족수는 모든 일반적인 다이나모 구현에서 선택 사항이다.
    * Riak에서는 기본적으로 활성화 돼 있지만 Cassandra와 Voldemort는 비활성화돼 있다.
### 동시 쓰기 감지
* Dynamo 스타일 데이터베이스는 여러 클라이언트가 동시에 같은 키에 쓰는 것을 허용하기 때문에 엄격한 정족수를 사용하더라도 충돌이 발생한다.
* 문제는 다양한 네트워크 지연과 부분적인 장애 때문에, 이벤트가 다른 노드에 다른 순서로 도착할 수 있다는 것이다.
![image](https://user-images.githubusercontent.com/30207544/171026904-7d2c96b1-5445-4ae6-a19d-7a97d71a0560.png)
* 두 클라이언트 A,B가 키 X를 동시에 세 노드 데이터스토어에 기록하는 상황을 보여준다.
* 노드 1은 A로부터의 쓰기를 받지만, 순간적인 장에로 B로부터 쓰기를 받지 못한다.
* 노드 2는 A로부터의 쓰기를 먼저 받고, 그 다음 B로부터 쓰기를 받는다.
* 노드 3은 B로부터의 쓰기를 먼저 받고, 그 다음 A로부터 쓰기를 받는다.
* 각 노드가 클라이언트로부터 쓰기 요청을 받을 때마다 키의 값을 단순하게 덮어 쓴다면 그림의 마지막 `GET` 요청에서 볼 수 있듯이 노드들은 영구적으로 일관성이 깨진다.
    * `GET` 요청에서 노드 2는 X의 최종 값을 B로 생각하는 반면 다른 노드들은 A라고 생각한다.
* 최종적인 일관성을 달성하기 위해 복제본들은 동일한 값이 돼야 한다. 
    * 데이터 손실을 피하려면 애플리케이션 개발자는 데이터베이스 내부에서 충돌을 어떻게 다루는지 알아야 하는데, 다음에서 알아본다.

#### 최종 쓰기 승리(동시 쓰기 버리기)
* 최종적으로 값을 수렴하기 위한 접근 방식 하나는 각 복제본이 가진 "예전" 값을 버리고 가장 "최신"값으로 덮어쓰는 방법이다.
    * 어떤 쓰기가 "최신"인지 명확하게 결정할 수 있는 한 모든 쓰기는 최종적으로 모든 복제 서버에 복사되므로 복제본은 최종적으로 동일한 값으로 수렴한다.
* 쓰기가 자연적인 순서가 없지만 임의의 순서를 정할 수 있다. 예를 들어, 쓰기에 타임스탬프를 붙여 가장 "최신"이라는 의미로 제일 큰 타임스탬프를 선택하고 예전 타임스탬프를 가진 쓰기는 무시한다.
    * 최종 쓰기 승리(LWW)라 부르는 충돌 해소 알고리즘은 카산드라에서 유일하게 제공하는 충돌 해소 방법이고, Riak에서는 선택적 기능이다.
    * LWW는 최종적 수렴 달성이 목표지만 지속성을 희생한다.
        *동일한 키에 여러 번의 동시 쓰기가 있다면 클라이언트에게 모두 성공으로 보고될지라도 (w개의 복제 서버에 쓰여졌기 때문에) 쓰기 중 하나만 남고 다른 쓰기는 조용히 무시된다.
    * 더욱이 LWW는 동시 쓰기가 아니라도 쓰기가 삭제될 수 있다. 이는 "이벤트 순서화용 타임스탬프"에서 설명한다.
* LWW로 데이터베이스를 안전하게 사용하는 유일한 방법은 키를 한번만 쓰고 이후에는 불변 값으로 다루는 것이다.
    * 이 방법은 같은 키를 동시에 갱신하는 상황을 방지한다.
    * 예를 들어, 카산드라를 사용할 때 추천하는 방법은 키로 UUID를 사용해 모든 쓰기 작업에 고유한 키를 부여하는 것이다.
#### "이전 발생(happens-before)" 관계와 동시성
* 두 가지 작업이 동시에 수행됐는지 여부를 어떻게 결정하는가는 다음과 같다.
![image](https://user-images.githubusercontent.com/30207544/171031140-b8f2c813-cd7f-41fb-b9e1-189791e0a0a2.png)
    * 위 그림에서 두 개의 쓰기는 동시에 수행되지 않았다.
    * A의 삽입이 B의 증가 이전에 발생했다.
    * B가 증가시킨 값은 A가 삽입한 값이기 때문이다.
    * 즉, B 작업은 A 작업 기반이기 때문에 B작업은 나중에 발생해야 한다. 
    * 이를 B는 A에 인과성이 있다고 한다.
![image](https://user-images.githubusercontent.com/30207544/171031460-30725f71-898c-4314-9720-2cbcfde86221.png)
* 반면 위 그림에서, 두 개의 쓰기는 동시에 수행됐다. 클라이언트가 작업을 시작할 때 다른 클라이언트가 동일한 키에 대한 작업을 수행했는지 알지 못한다. 따라서 작업에 인과성이 없다.
* 작업 B가 작업 A에 대해서 알거나 A에 의존적이거나 어떤 방식으로든 A를 기반으로 한다면 작업A는 B의 이전 발생(happens-before)이다.
* 한 작업이 다른 작업 이전에 발생했는지가 동시성의 의미를 정의하는 핵심이다.
* 따라서, 작업A와 B가 있다면 세 가지 가능성이 있다.
    * B 이전에 A가 발생.
    * A 이전에 B가 발생.
    * A와 B가 동시에 발생.
* 위 2경우는, 나중 작업은 이전 작업을 덮어쓸 수 있지만, 작업이 동시에 발생하면 충돌을 해소해야 한다.
#### 이전 발생(happens-before) 관계 파악하기
* 이전 발생 관계를 파악해보자.
![image](https://user-images.githubusercontent.com/30207544/171032507-73ce5e40-7487-41bf-8ebd-cf315aba2b01.png)
* 위 그림은 두 클라이언트가 장바구니에 동시에 상품을 추가하는 것을 보여준다. 처음에는 장바구니가 비어 있고, 두 클라이언트가 데이터베이스에 쓰기를 다섯 번 수행한다.
    * 클라이언트 1은 장바구니에 우유를 추가한다. 이것은 키에 첫 번째 쓰기이므로 서버는 저장에 성공하고, 버전 1을 할당한다. 또한 서버는 클라이언트에게 값을 다시 보여준다.
    * 클라이언트 2는 클라이언트 1이 현재 우유를 추가했다는 사실을 알지 못한 상태에서, 장바구니에 달걀을 추가한다. (클라이언트 2는 달걀이 장바구니에 있는 유일한 상품으로 생각한다.) 서버는 버전 2를 해당 쓰기에 할당하고, 달걀과 우유를 개별 값으로 저장한다. 그 다음 클라이언트에게 버전 2를 가진 두 개의 값을 반환한다.
    * 클라이언트 2가 쓴 내용을 모르는 클라이언트 1은 밀가루를 장바구니에 추가한다. 그래서 현재 장바구니에는 [우유, 밀가루]가 있다고 생각한다. 이 값은 이전에 서버가 클라이언트 1에게 준 버전 1과 함께 서버에 전송된다. 서버는 이 버전 번호로 이전의 [우유]를 [우유, 밀가루] 쓰기로 대체하지만, [달걀]과도 동시라는 사실을 안다. 따라서 서버는 [우유, 밀가루]에 버전 3을 할당하고 버전 1의 [우유] 값을 덮어쓴다. 하지만 버전 2의 [달걀]은 유지하고 남은 두 값을 클라이언트에게 반환한다.
    * 한편 클라이언트2는 클라이언트 1이 밀가루를 추가했는지 모른 채 햄을 장바구니에 추가하려한다. 클라이언트 2는 지난 응답에서 서버로부터 [우유]와 [달걀]이라는 두 값을 받았기 때문에, 클라이언트는 응답 값에 햄을 추가해서 새로운 값인 [달걀, 우유, 햄]으로 합친다. 이 값은 예전 버전인 2를 가지고 서버에 전송한다. 서버는 버전 2로 [달걀]을 덮어쓰지만, [우유, 밀가루]는 동시에 수행된 사실을 감지하기 때문에 [우유, 밀가루]라는 두 값은 버전3으로 남아 있고 [달걀, 우유, 햄]은 버전4를 가지게 된다.
    * 마지막 클라이언트 1이 베이컨을 추가하려고 한다. 이전에 서버로부터 버전 3의 [우유, 밀가루]와 [달걀]을 받았으므로 여기에 베이컨을 추가해 최종값인 [우유, 밀가루, 달걀, 베이컨]으로 합쳐서 버전 3으로 서버에 전송한다. 이 값은 [우유, 밀가루]를 덮어쓰지만 [달걀, 우유, 햄]은 동시에 수행됐기 때문에 서버는 이 두개의 동시 수행된 값을 유지한다.
![image](https://user-images.githubusercontent.com/30207544/171033802-9c8618f2-ba18-4a1b-b1c3-514b39995e6b.png)
* 화살표는 어떤 작업이 다른 작업 이전에 발생했는지와 나중 작업이 이전에 수행된 작업을 알거나 의존했다는 사실을 나타낸다.
* 이 예에서 클라이언트는 서버 데이터와 동일한 최신 상태로 유지 못한다. 항상 다른 작업이 동시에 수행됐기 때문이다.
* 그러나 최종적으로 예전 버전의 값을 덮어쓰기 때문에 손실된 쓰기는 없다.
* 서버는 버전 번호를 보고 두 작업이 동시에 수행됐는지 여부를 결정할 수 있으므로, 값 자체를 해석할 필요는 없다.
* 이 알고리즘은 다음과 같이 작동한다.
    * 서버가 모든 키에 대한 버전 번호를 유지하고 키를 기록할 때마다 버전 번호를 증가시킨다. 기록한 값은 새로운 버전 번호를 가지고 저장된다.
    * 클라이언트가 키를 읽을 때는 서버는 최신 버전뿐만 아니라, 덮어쓰지 않은 모든 값을 반환한다. 클라이언트는 쓰기 전에 키를 읽어야 한다.
    * 클라이언트가 키를 기록할 때는 이전 읽기의 버전 번호를 포함해야 하고, 이전 읽기에서 받은 모든 값을 함께 합쳐야 한다. 
    * 서버가 특정 번호를 가진 쓰기를 받을 때, 해당 버전 이하 모든 값을 덮어 쓸 수 있다. 하지만 이보다 높은 버전 번호의 모든 값은 유지해야 한다. 이 값들은 유입된 쓰기와 동시에 발생했기 때문이다.
* 쓰기가 이전 읽기의 버전 번호를 포함하면 쓰기가 수행되기 이전 상태를 알 수 있다.
#### 동시에 쓴 값 병합
* 위 알고리즘은 어떤 데이터도 자동으로 삭제되지 않음을 보장하지만, 불행히도 클라리언트가 추가적으로 작업을 수행해야 한다.
* 여러 작업이 동시에 발생하면 클라이언트는 동시에 쓴 값을 합쳐 정리해야한다.
    * 리악은 이런 동시 값을 형제(Sibling) 값이라 한다.
* 형제(Sibling) 값의 병합은, 다중 리더 복제에서 충돌을 해소하는 문제와 본질적으로 같다.
    * 간단한 접근 방식으로 버전 번호나 타임스탬프 기반으로 하나의 값을 선택하는 방법(최종 쓰기 승리)이 있지만, 데이터 손실이 생길 수 있다. 
* 그래서 장바구니에서, 형제(Sibling)를 병합하는 합리적인 접근 방식은 합집합을 취하는 것이였다. 최종 두 개의 형제(Sibling)는 [우유, 밀가루, 달걀, 베이컨]과 [달걀, 우유, 햄]이다. 우유와 달걀은 비록 한번씩 썻지만, 두 형제(Sibling)에 모두 나타난다. 병합된 값은 [우유, 밀가루, 달걀, 베이컨, 햄]이 된다.
* 장바구니에서 상품 추가 외에 제거도 할 수 있게 하려면 형제(Sibling)의 합집합으로는 올바른 결과를 얻을 수 없다.
    * 두 형제(Sibling) 장바구니를 합치고, 그중 하나만 제거하면 형제(Sibling)의 합집합에 제거된 상품이 다시 나타난다.
    * 이 문제를 방지하려면 상품을 제거할 때 데이터베이스에서 단순히 삭제하면 안되고, 형제(Sibling)를 병합할 때 상품을 제거했음을 나타내기 위한 해당 버전 번호에 표시를 남겨둬야 한다.
    * 이런 삭제 표시를 **툼스톤**이라 한다.
#### 버전 벡터
* 위 예에서는 단일 복제본으로 예를 들었지만, 다중 복제본의 리더가 없는 경우에는 조금 다른 알고리즘을 사용한다.
* 위 예에서는 작업 간 의존성을 파악하기 위해 단일 버전을 사용했찌만, 다중 복제본의 동시 쓰기를 받아들일때는 키당 버전 번호뿐만 아니라 복제본당 버전 번호도 사용해야 한다.
    * 각 본제본의 쓰기를 처리할 때 자체 버전 번호를 증가시키고, 각기 다른 복제본의 버전 번호도 계속 추적해야 한다. 이 정보는 덮어쓸 값과 형제(Sibling)로  유지할 값을 나타낸다.
* 모든 복제본의 번호 모음을 버전 벡터(Version vector)라고 부른다.
* 버전 벡터는 형제를 병합해야할 시에, 하나의 복제본을 읽은 다음 이어 다른 복제본에 다시 쓰는 작업으로 안전함을 보장한다. 이렇게 하면 형제가 생성돼도 형제가 올바르게 병합되는 한 데이터 손실은 없다.

### 정리
#### 복제의 용도
* 고가용성 : 한 장비가 다운될 때도 시스템이 계속 동작하게 한다.
* 연결이 끊긴 작업 : 네트워크 중단이 있을 때도 애플리케이션이 계속 동작할 수 있게 한다.
* 지연 시간 : 지리적으로 사용자에게 가까이 데이터를 배치해 사용자가 더 빠르게 작업할 수 있게 한다.
* 확장성 : 복제본에서 읽기를 수행해 단일 장비에서 다룰 수 있는 양보다 많은 양의 읽기 작업을 처리할 수 있다.
#### 복제의 세가지 주요 접근 방식
* 단일 리더 복제 : 클라이언트는 모든 쓰기를 단일 노드로 전송하고 리더는 데이터 변경 스트림을 다른 복제 서버로 전송한다. 읽기는 모든 복제 서버가 수행할 수 있지만 팔로워의 읽기는 오래된 값일 수 있다.
* 다중 리더 복제 : 클라이언트는 각 쓰기를 여러 리더 노드 중 쓰기를 받아들일 수 있는 노드로 전송한다. 리더는 데이터 변경 이벤트 스트림을 다른 리더와 모든 팔로워 노드로 전송한다.
* 리더 없는 복제 : 클라이언트는 각 쓰기를 여러 노드로 전송한다. 클라이언트는 오래된 데이터를 감지하고 이를 바로잡기 위해 병렬로 여러 노드에서 읽는다.
#### 복제 지연 시 필요한 일관성 모델
* 쓰기 후 읽기 일관성 : 사용자는 자신이 제출한 데이터를 항상 볼 수 있어야 한다.
* 단조 읽기 : 사용자가 어떤 시점에 데이터를 본 후에는 예전 시점의 데이터는 나중에 볼 수 없다.
* 일관된 순서로 읽기 : 사용자는 인과성이 있는 상태의 데이터를 봐야 한다. 예를 들어 질문과 그에 대한 답을 순서에 맞게 봐야 한다.


